//#include <stdio.h>
//#include <stdlib.h> // 引入stdlib以使用动态内存分配
////时间复杂度 平均为O(n^1.3)  不稳定
//// 希尔排序函数，参数为待排序数组和数组大小
//void shellsort(int data[], int n) {
//    int *delta, k, i, t, dk, j; // 定义变量：增量数组指针、循环变量、临时变量、当前增量
//
//    // 动态分配增量数组，最多存储 n/2 个增量
//    delta = (int *)malloc(sizeof(int) * (n / 2));
//    k = n; // 初始化 k 为数组大小
//    i = 0; // 初始化增量数组索引
//
//    // 生成增量序列
//    do {
//        // 计算增量：将 k 减半
//        k /= 2; // 或 k = k / 2
//
//        // 继续直到增量小于等于1
//        if (k > 0) {
//            delta[i++] = k; // 存储当前增量到增量数组中，并更新索引
//        }
//    } while (k > 0); // 继续直到 k 小于等于 0
//
//    // 使用增量进行排序
//    i = 0; // 重置增量数组索引
//
//
//    //大的元素：被移动到小的元素的后面，保持组内元素的升序排列。
//    //小的元素：插入到原来大元素的位置，以确保在当前组内完成排序。
//
//    while ((dk = delta[i]) > 0) {
//        //delta 是之前生成的增量序列数组，这里通过 delta[i] 获取当前的增量值 dk。
//        //while 循环的条件是当前增量 dk 大于 0，如果 dk 为 0，说明所有增量都已经处理完，排序结束。
//        //每次处理一个增量序列 dk，意味着按照步长 dk 对数组的元素进行分组，然后在每组内进行插入排序。
//        //遍历每个增量
//        for (k = dk; k < n; ++k) { // 从当前增量位置开始
//            if (data[k - dk] > data[k]) {
//                //k 是数组的下标，表示当前要处理的元素     k - dk 是指当前元素的前一个组内元素
//                //判断当前元素（data[k]）是否小于它前面的那个增量步长的元素（data[k - dk]）
//                //如果 data[k] 小于 data[k - dk]，说明它们的顺序不正确，我们需要将 data[k] 插入到前面去，保持组内元素的升序。
//                //如果 data[k] 大于或等于 data[k - dk]，说明它们已经是正确的顺序，不需要插入，这次比较结束。
//                t = data[k]; // 保存当前元素
//
//                // 移动元素：将比当前元素大的元素向后移动
//                for (j = k - dk; j >= 0 && t < data[j]; j -= dk) {
//                    //j = k - dk，从当前元素的前一个增量步长位置 k - dk 开始，向前遍历每个增量步长的元素，直到找到一个比 t 小的元素位置
//                    //t < data[j] 表示 t（当前元素的值）比 data[j] 小，则我们需要将 data[j] 向后移动，为插入 t 腾出位置
//                    // j -= dk 表示按照步长 dk 向前移动，继续比较更前面的元素
//                    //当条件不满足（即找到了一个比 t 小的元素，或者遍历到了数组的开头 j >= 0 为假时），这个循环结束。
//                    data[j + dk] = data[j]; // 这一步负责将元素 data[j] 向后移动到 j + dk 位置，为插入 t 腾出位置。通过不断移动前面的元素，最终找到合适的插入位置
//                }
//
//                data[j + dk] = t; // 上一步循环结束后，j 是不符合 t < data[j] 的位置，因此 t 应该插入到 j + dk 位置。 这一步将保存的 t 插入到合适的位置，完成排序
//            }
//        }
//
//        ++i; // 处理下一个增量
//    }
//
//    // 释放动态分配的内存
//    free(delta); // 释放增量数组的内存
//}
//
//// 主函数，测试希尔排序
//int main(void) {
//    // 初始化待排序数组
//    int data[] = {
//        8, 5, 7, 10, 2, 9, 5, 6, 3
//    };
//    // 增量序列 delta[] = {4, 2, 1}。
//    // 增量 dk = 4  先按步长 4 对数组进行分组：(8, 2)，(5, 9)，(7, 5)，(10, 6)，(3)   第一轮比较完 data[] = {2, 5, 5, 6, 8, 9, 7, 10, 3}
//    // 增量 dk = 2    因为步长是 2，意味着每隔两个元素就会组成一组，索引为偶数的元素（0, 2, 4, 6, 8）被分到第一组，索引为奇数的元素（1, 3, 5, 7）被分到第二组 data[] = {2, 3, 5, 6, 5, 9, 7, 10, 8}
//    // 增量 dk = 1  整个数组被当作一组来看待，并使用插入排序逐步进行排序
//    // 对每组内的元素进行插入排序。
//    int n = sizeof(data) / sizeof(data[0]); // 计算数组大小
//
//    // 调用希尔排序函数
//    shellsort(data, n);
//
//    // 输出排序后的数组
//    printf("排序后的数组: ");
//
//    for (int i = 0; i < n; i++) {
//        printf("%d ", data[i]); // 打印每个元素
//    }
//
//    printf("\n"); // 换行
//
//    return 0; // 程序结束
//}
