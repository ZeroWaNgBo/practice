//#include <stdio.h>
//// 时间复杂度 O(NW)   N物品数量 W背包容量
//// 空间复杂度 O(NW)
//// 定义物品数量为 4
//#define N 4
//// 定义背包容量为 5
//#define W 5
//
//// 定义函数用于比较两个整数并返回较大值
//int max(int a, int b) {
//    return a > b? a : b;
//}
//
//int main(void) {
//    // 物品价值数组，第一个元素为 0，实际物品从下标 1 开始
//    int n[] = {0, 2, 4, 5, 6};
//    // 物品重量数组，第一个元素为 0，实际物品从下标 1 开始
//    int w[] = {0, 1, 2, 3, 4};
//
//    // 动态规划表    子问题解二维数组，用于存储不同物品数量和背包容量下的最大价值
//    int f[N + 1][W + 1] = {};
//
//    int i, j;
//    // 外层循环遍历物品数量
//    for (i = 1; i <= N; i++) {
//        // 外层循环，遍历每一个物品 i，从第 1 个物品开始，一直到第 N 个物品。
//        // 每次循环的目的是决定当前物品 i 是否要放入背包。
//        
//        for (j = 1; j <= W; j++) {
//            // 内层循环，遍历背包的每一个容量 j，从 1 到 W（即背包的最大容量）。
//            // 这表示我们要考虑在背包容量为 j 时，是否要放入当前的物品 i。
//
//            f[i][j] = f[i - 1][j];
//            // 默认情况下，我们不选择第 i 个物品，因此此时的最大价值是“前 i-1 个物品在背包容量为 j 时的最大价值”。
//            // f[i - 1][j] 的含义：不选物品 i 的时候的最大价值。
//
//            if (j >= w[i]) {
//                // 如果当前背包容量 j 足够容纳物品 i（即 j >= 物品 i 的重量 w[i]），
//                // 那么我们可以考虑是否应该放入物品 i。
//
//                // 接下来我们比较两种情况：不选物品 i 和选物品 i，取较大值来更新 f[i][j]。
//
//                f[i][j] = max(f[i][j], f[i - 1][j - w[i]] + n[i]);
//                // 第一种情况：f[i][j] 表示不选物品 i 的情况，之前已经赋值了 f[i-1][j]；
//                // 第二种情况：我们选取物品 i，那么背包的剩余容量为 j - w[i]，
//                // 此时背包能装的最大价值为 f[i-1][j-w[i]]，这是在容量 j-w[i] 下不考虑物品 i 的最大价值。
//                // 加上当前物品 i 的价值 n[i]，就是选取物品 i 的价值总和：f[i-1][j-w[i]] + n[i]。
//                // 我们需要在不选物品 i 和选物品 i 的两种情况中，选择价值较大的那个，因此用 max() 函数。
//            }
//        }
//    }
//
//
//    // 输出所有物品在背包容量为 W 时的最大价值
//    printf("%d\n", f[N][W]);
//
//    // 输出子问题解数组 f，用于查看中间结果
//    for (i = 0; i <= N; i ++ ) {
//        for (j = 0; j <= W; j ++ ) {
//            printf("%d ", f[i][j]);
//        }
//        printf("\n");
//    }
//
//    return 0;
//}
